'use strict';

class SymbolTableEntry {
  constructor(name, type, isGenerated, version, table) {
    this.name = name;
    this.type = type;

    // Is this generated by the tool or user code.
    this.isGenerated = isGenerated;

    // Used to differentiate between variables with the same name in different
    // scopes because VTL only has a single scope.
    this.version = version;

    // The symbol table that owns this entry.
    this.table = table;
  }
}


class SymbolTable {
  #symbols;
  #versions;

  constructor(parent = null) {
    this.#symbols = new Map();
    this.parent = parent;

    if (parent === null) {
      this.#versions = new Map();
    } else {
      this.#versions = parent.#versions;
    }
  }

  symbol(name) {
    // Create a new symbol or retrieve an existing one in the same scope.
    const existing = this.lookup(name);

    if (existing !== undefined && existing.table === this) {
      return existing;
    }

    const currentVersion = this.#versions.get(name);
    const version = currentVersion === undefined ? 0 : currentVersion + 1;
    const symbol = new SymbolTableEntry(name, null, false, version, this);

    this.#symbols.set(name, symbol);
    this.#versions.set(name, version);
    return symbol;
  }

  lookup(name) {
    for (let scope = this; scope !== null; scope = scope.parent) {
      const symbol = scope.#symbols.get(name);

      if (symbol !== undefined) {
        return symbol;
      }
    }

    return undefined;
  }

  createNestedScope() {
    return new SymbolTable(this);
  }
}

module.exports = { SymbolTable, SymbolTableEntry };
